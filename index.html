<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>水没検査 入力パネル（修正版）</title>
<style>
:root{
--bg:#0f172a;--card:#111827;--muted:#94a3b8;--ok:#16a34a;--warn:#f59e0b;--err:#ef4444;--ink:#e5e7eb;--accent:#22d3ee;
--font-size-base:20px;
--font-size-large:28px;
--btn-padding:20px 24px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;background:linear-gradient(160deg,#0b1222,#0f172a 40%,#0c1226);color:var(--ink);font-size:var(--font-size-base)}
.wrap{max-width:1100px;margin:0 auto;padding:20px}
header{display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin-bottom:16px}
header h1{font-size:var(--font-size-large);margin:0 8px 0 0;font-weight:800;letter-spacing:.02em}
.card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:18px;box-shadow:0 10px 24px rgba(0,0,0,.25)}
.section-title{font-weight:800;margin:8px 2px 12px;color:#cbd5e1;font-size:var(--font-size-base)}
.row{display:flex;gap:14px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(4,minmax(150px,1fr));gap:14px}
@media (max-width:900px){.grid{grid-template-columns:repeat(2,minmax(150px,1fr))}}
.btn{border:1px solid #1f2937;background:#0b1222;color:var(--ink);border-radius:14px;padding:var(--btn-padding);font-weight:800;cursor:pointer;letter-spacing:.02em;font-size:var(--font-size-base)}
.btn.big{height:100px;font-size:var(--font-size-large);border-radius:16px;background:linear-gradient(180deg,#0f1b33,#0a1326);box-shadow:inset 0 0 0 1px rgba(255,255,255,.04),0 8px 20px rgba(0,0,0,.2)}
.btn:disabled{opacity:.5;cursor:not-allowed}
.btn.active {
  background: #1e40af;  /* 濃い青 */
  border-color: #60a5fa;
}


.inq-wrap{
  display:flex; align-items:center; justify-content:center; gap:10px;
}
.a-btn{
  min-width:64px; padding:12px 16px;
  font-size:24px; font-weight:800; line-height:1;
  border-radius:12px; border:1px solid #3b82f6;
  background:#2563eb; color:#fff; cursor:pointer;
}
.a-btn:active{ transform:translateY(1px); }


.btn.ok{background:#052e1a;border-color:#14532d}
.btn.err{background:#3b0a0a;border-color:#7f1d1d}
.pill{display:inline-flex;align-items:center;gap:8px;background:#0b1222;border:1px solid #233046;color:var(--ink);padding:12px 14px;border-radius:999px;font-size:var(--font-size-base)}
.pill input,.pill select{background:transparent;border:none;color:var(--ink);outline:none;font-size:var(--font-size-base);min-width:120px}
.chips{display:flex;flex-wrap:wrap;gap:10px}
.chip{border:1px solid #233046;border-radius:999px;padding:14px 18px;background:#0b1222;color:var(--ink);cursor:pointer;font-weight:700;font-size:var(--font-size-base)}
.chip.active{border-color:#2aa6c8;background:#0e1a2c}
.muted{color:var(--muted);font-size:18px}
.log{margin-top:14px;font-size:16px;color:var(--muted);max-height:180px;overflow:auto;white-space:pre-wrap}
.toast{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(2,6,23,.95);border:2px solid #ef4444;color:#fff;padding:20px 24px;border-radius:16px;box-shadow:0 12px 26px rgba(0,0,0,.45);opacity:0;transition:.3s;font-size:var(--font-size-large);font-weight:800;text-align:center;z-index:1000}
.toast.show{opacity:1}
.toast{ pointer-events:none; }
input[type="text"], input[type="number"], input[type="search"]{background:#0b1222;border:1px solid #233046;color:#fff;border-radius:12px;padding:12px 14px;font-size:var(--font-size-base)}
.divider{height:14px}
.hidden{display:none}
.kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0b1222;border:1px solid #233046;border-radius:6px;padding:4px 8px;font-size:16px}

/* 検査種別ボタンの文字整列（高さ揃え） */
#modeGrid .btn {
  white-space: normal;      /* 折り返し許可 */
  line-height: 1.3;         /* 行間を少し詰める */
  min-height: 90px;         /* 高さを統一 */
  display: flex;            /* Flexで中央寄せ */
  align-items: center;      /* 縦中央 */
  justify-content: center;  /* 横中央 */
  text-align: center;       /* テキスト中央 */
  padding: 12px;            /* 内側余白を均等に */
}


/* 検査者ボタンを3等分 */
#operatorBar{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;width:100%}
#operatorBar .btn{width:100%;text-align:center}

/* 前後左右の大ボタン（4分割・丸） */
.dir-grid{
  display:grid;
  grid-template-columns:repeat(4,1fr);
  gap:14px;
  margin:12px 0;
}
.dir-btn{
  border:1px solid #233046;
  background:#0b1222;
  color:#fff;
  border-radius:9999px;
  /* ↓サイズを“確実に”上げる */
  min-height: clamp(56px, 9vh, 88px);
  padding: 0;                 /* 高さは min-height で管理 */
  font-size: clamp(18px, 2.6vw, 28px);
  font-weight:800;
  cursor:pointer;
  width:100%;
}
.dir-btn.active{ border-color:#2aa6c8; background:#0e1a2c; }

/* ロケーション削除ボタンスタイル */
.loc-item {
  display: flex;
  align-items: center;
  gap: 8px;
}
.remove-btn {
  background: var(--err);
  border: 1px solid #7f1d1d;
  color: white;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 14px;
  cursor: pointer;
}
.btn{ -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

/* タップ/クリック直後の一瞬のフィードバック */
.btn:active {
  background:#1e40af;          /* 目立つ色に調整可 */
  border-color:#60a5fa;
  transform: translateY(1px);  /* 押し込み感 */
}
/* iOS向けのタップ最適化（任意） */
.btn { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

/* 問い合わせNo.を画面上端から少し下に止める */
#inqNo { scroll-margin-top: 120px; }

.fab{
  position:fixed; right:20px; bottom:20px; z-index:999;
  background:#1f2937; color:#fff; border:1px solid #334155;
  padding:14px 18px; border-radius:999px; font-weight:800; cursor:pointer;
}
.overlay{
  position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:1000;
  display:flex; align-items:center; justify-content:center;
}
.overlay.hidden{ display:none; }
.overlay-inner{
  width:min(900px,92vw); max-height:86vh; overflow:auto;
  background:#0f172a; color:#e5e7eb; border-radius:16px; padding:16px; border:1px solid #1f2937;
}
.overlay-head{ display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;}
.overlay-head .title{ font-size:20px; font-weight:800;}
.overlay-head .close{ background:#111827; color:#e5e7eb; border:1px solid #334155; padding:6px 10px; border-radius:8px; cursor:pointer;}
.block{ margin-bottom:12px; }
.updated{ font-size:12px; color:#94a3b8; }

/* 押下中の一瞬だけ付くクラス（選択の .active とは別物） */
.btn.pressed, .chip.pressed {
  transform: translateY(1px);
  filter: brightness(1.15);
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
  transition: filter .06s, transform .06s;
}




</style>
</head>
<body>
<div class="wrap">
<header>
<h1>水没検査 入力パネル</h1>
<span class="muted">（検査者 → 種別 → 合否 → 分岐）</span>
</header>

<!-- 検査者 -->
<section class="card" aria-label="検査者">
<div class="section-title">検査者</div>
<div class="row" id="operatorBar"></div>
<div class="muted" style="margin-top:6px">※ 作業者が変わったら別のボタンを押して切替。構成の変更は <span class="kbd">CONFIG.OPERATORS</span> を編集。</div>
</section>

<div class="divider"></div>

<!-- 種別 -->
<section class="card" aria-label="種別">
  <div class="section-title">検査種別</div>
  <div class="grid" id="modeGrid"></div>
</section>

<div class="divider"></div>

<!-- Mode1 のみ表示するサブ選択 -->
<section class="card hidden" id="mode1SubCard" aria-label="Mode1サブ選択">
  <div class="section-title">サブ選択（Mode1のみ）</div>
  <div class="row" id="mode1SubBar">
    <button class="chip" id="subPP"      data-value="PP">PPサンプル</button>
    <button class="chip" id="subAccept"  data-value="ACCEPT">受け入れ検品</button>
  </div>
</section>

<div class="divider"></div>

<!--保留ボタン-->
<section class="card">
  <div class="section-title">合否</div>
  <div class="row">
    <button class="btn ok" id="btnPass">合格</button>
    <button class="btn err" id="btnFail">不合格</button>
    <!-- ★保留ボタン追加（初期は非表示）-->
    <button class="btn" id="btnHold" style="display:none;">保留</button>
  </div>
</section>

<div class="divider"></div>

<!-- 分岐（2:出荷前修理の不合格時） -->
<section class="card hidden" id="branchCard" aria-label="不合格分岐">
  <div class="section-title">不合格（出荷前修理）</div>
  <div class="row">
    <button class="btn" data-reason="same" id="btnSame">1 同箇所</button>
    <button class="btn" data-reason="diff" id="btnDiff">2 別箇所</button>
    <button class="btn" data-reason="complex" id="btnComplex">3 同別複合</button>
  </div>
  <div class="row" style="margin-top:10px">
    <button class="btn ok hidden" id="btnBranchSend">送信（分岐結果）</button>
  </div>
</section>

<div class="divider"></div>

<!-- 1:出荷前製品 不合格時の詳細入力 -->
<section class="card hidden" id="preProductFailCard" aria-label="出荷前製品・不合格 詳細">
  <div class="section-title">出荷前製品・不合格 詳細</div>
  <div class="row">
    <!-- 生産ライン（Mode1 不合格時） -->
<div class="section-title" style="margin-top:10px">生産ライン</div>
<div class="row" id="lineChips1">
  <span class="chip" data-line="内製1">内製1</span>
  <span class="chip" data-line="内製2">内製2</span>
  <span class="chip" data-line="ファンクリエーション">ファンクリエーション</span>
</div>
    <label class="pill">製造No.
      <input id="mfNo" type="text" placeholder="例) 123456" inputmode="numeric" pattern="[0-9]{6}" />
    </label>
    <label class="pill">品名（音声入力可）
      <input id="prodName" type="text" placeholder="例) クロコドライ" />
    </label>
  </div>
<!-- 前・後・左・右（mode=1用） -->
<div class="dir-grid" id="dirGrid1">
  <button class="dir-btn" data-kind="position" data-value="front">前</button>
  <button class="dir-btn" data-kind="position" data-value="back">後</button>
  <button class="dir-btn" data-kind="side"     data-value="L">左</button>
  <button class="dir-btn" data-kind="side"     data-value="R">右</button>
</div>

  <div class="section-title" style="margin-top:10px">水没箇所（必須）</div>
  <div class="grid" id="partGrid1"></div>
  <div class="section-title" style="margin-top:10px">不良種別（必須）</div>
  <div class="chips" id="defectChips1"></div>
  <div class="row" style="margin-top:14px">
    <button class="btn ok" id="btnSendPre1">送信</button>
  </div>
</section>

<div class="divider"></div>

<!-- 2:出荷前修理 不合格=同箇所 詳細（複数箇所の繰り返し） -->
<section class="card hidden" id="preRepairSameCard" aria-label="出荷前修理 同箇所 詳細">
  <div class="section-title">出荷前修理・同箇所 詳細入力</div>
<div class="card" style="margin:12px 0; padding:24px; text-align:center; background:#222; border:2px solid #4ade80;">
  <div class="section-title" style="font-size:24px; margin-bottom:12px; color:#4ade80;">問い合わせNo.（必須）</div>


  <!-- ここから置き換え -->
  <div class="inq-wrap">
    <button type="button" id="btnPrefillA" class="a-btn">A</button>
    <input id="inqNo" type="text"
           placeholder="例）A12345 または 123456"
           inputmode="numeric"
           style="font-size:28px; padding:12px 16px; width:90%; max-width:400px;
                  border-radius:8px; border:none; text-align:center;
                  background:#0b1222; color:#fff;" />
  </div>
  <!-- ここまで -->
</div>

  <!-- 検査回数入力 -->
<div class="card" style="margin:12px 0; padding:24px; text-align:center; background:#222; border:2px solid #60a5fa;">
  <div class="section-title" style="font-size:20px; margin-bottom:8px; color:#60a5fa;">検査回数</div>
  <input id="inspectionCount" type="number" min="1"
         placeholder="例: 1"
         style="font-size:24px; padding:10px 16px; width:90%; max-width:200px;
                border-radius:8px; border:none; text-align:center;
                background:#0b1222; color:#fff;" />
</div>


<!-- 前・後・左・右（mode=2用） -->
<div class="dir-grid" id="dirGrid2">
  <button class="dir-btn" data-kind="position" data-value="front">前</button>
  <button class="dir-btn" data-kind="position" data-value="back">後</button>
  <button class="dir-btn" data-kind="side"     data-value="L">左</button>
  <button class="dir-btn" data-kind="side"     data-value="R">右</button>
</div>

  <div class="section-title" style="margin-top:10px">水没箇所（必須）</div>
  <div class="grid" id="partGrid2"></div>
  <div class="section-title" style="margin-top:10px">不良種別（必須）</div>
  <div class="chips" id="defectChips2"></div>
  <div class="row" style="margin-top:12px">
    <button class="btn" id="btnAddLoc">＋ 箇所を追加</button>
  </div>
  <div class="muted" style="margin-top:8px">※ 追加を押すと現在の選択が保存されます。削除も可能です。</div>
  <div class="row" id="locPreview" style="margin-top:8px"></div>
  <div class="row" style="margin-top:10px">
    <button class="btn ok" id="btnSendPre2" disabled>送信（保存した箇所を登録）</button>
  </div>
</section>

<div class="log" id="log"></div>
</div>
<div class="toast" id="toast"></div>

<!-- 右下にフローティングボタン -->
<button id="btnOpenSummary" class="fab">📊 進捗</button>

<!-- 全画面オーバーレイ -->
<div id="summaryOverlay" class="overlay hidden">
  <div class="overlay-inner">
    <div class="overlay-head">
      <div class="title">📊 本日の進捗</div>
      <button id="btnCloseSummary" class="close">✕</button>
    </div>
    <div id="sumTotals" class="block"></div>
    <div id="sumByOp" class="block"></div>
    <div id="sumTimeline" class="block"></div>
    <div id="sumUpdated" class="updated"></div>
  </div>
</div>


<script>

function installPressFeedback() {
  // 押した瞬間
  document.addEventListener('pointerdown', (e) => {
    const el = e.target.closest('.btn, .chip');
    if (!el) return;
    el.classList.add('pressed');
    try { navigator.vibrate?.(10); } catch (_) {}
  }, { passive: true });

  // 押し終わり／キャンセル時に解除
  const clear = () => {
    document.querySelectorAll('.pressed').forEach(el => el.classList.remove('pressed'));
  };
  ['pointerup', 'pointercancel', 'pointerleave'].forEach(type => {
    document.addEventListener(type, clear, { passive: true });
  });

  // キーボード操作（スペース/Enter）でも反応
  document.addEventListener('keydown', (e) => {
    if (!(e.key === ' ' || e.key === 'Enter')) return;
    const el = e.target.closest('.btn, .chip');
    if (el) {
      el.classList.add('pressed');
      try { navigator.vibrate?.(8); } catch (_) {}
    }
  });
  document.addEventListener('keyup', () => {
    document.querySelectorAll('.pressed').forEach(el => el.classList.remove('pressed'));
  });
}

// ===== 設定 =====
const CONFIG = {
  DEPLOY_URL: "https://script.google.com/macros/s/AKfycbwUmMXYN5cBLAFRiXQ37DXY0ZdWbwjFBKb9krYj2ZM0aqgSeARlxa6MMpBqHLTravuM/exec",
  KEY: "KEY_2025_SUIKEN",
  OPERATORS: [
    {key:'松川(将)', label:'松川'},
    {key:'千葉(英)', label:'千葉'},
    {key:'高橋(未)', label:'高橋'}
  ],
  MODES: [
    {key:'1', label:'1 出荷前製品'},
    {key:'2', label:'2 出荷前修理品'},
    {key:'3', label:'3 初回修理品'},
    {key:'4', label:'4 初回修理品 裏検査'}
  ],
  PARTS: [
    { value: 'アンクル', label: 'アンクル' },
    { value: '腕', label: '腕(ウデ)' },
    { value: '肩', label: '肩(カタ)' },
    { value: 'グローブ', label: 'グローブ' },
    { value: '腰', label: '腰(コシ)' },
    { value: '背中', label: '背中(セナカ)' },
    { value: '袖口', label: '袖口(ソデグチ)' },
    { value: 'ソックス部ジョイント', label: 'ソックス部ジョイント' },
    { value: 'ソックス部本体', label: 'ソックス部本体' },
    { value: 'スネ', label: 'スネ' },
    { value: '尻', label: '尻(シリ)' },
    { value: '胸', label: '胸(ムネ)' },
    { value: 'ネック', label: 'ネック' },
    { value: '膝上', label: '膝上(ヒザウエ)' },
    { value: '膝裏', label: '膝裏(ヒザウラ)' },
    { value: '腹', label: '腹(ハラ)' },
    { value: 'パッド', label: 'パッド' },
    { value: 'ファスナー部', label: 'ファスナー部' },
    { value: 'フクラハギ', label: 'フクラハギ' },
    { value: '前股', label: '前股(マエマタ)' },
    { value: '後ろ股', label: '後ろ股(ウシロマタ)' },
    { value: '腿', label: '腿(モモ)' },
    { value: '腿裏', label: '腿裏(モモウラ)' },
    { value: '脇', label: '脇(ワキ)' },
    { value: 'リスト', label: 'リスト' }
  ],
  DEFECTS: [
    {key:'pinhole', label:'ピンホール'},
    {key:'seam', label:'接合部'},
    {key:'tape', label:'テープ'}
  ],
  SEND_DEBOUNCE_MS: 2000
};


function bindDirGrid(gridSelector, stateKey){
  const grid = document.querySelector(gridSelector);
  if(!grid) return;
  grid.querySelectorAll('.dir-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const kind = btn.dataset.kind;     // 'position' or 'side'
      const val  = btn.dataset.value;    // 'front'|'back' / 'L'|'R'
      if(kind === 'position'){
        const cur = state[stateKey].position;
        state[stateKey].position = (cur === val) ? '' : val; // 2回押しで解除
        grid.querySelectorAll('.dir-btn[data-kind="position"]')
            .forEach(b=>b.classList.toggle('active', state[stateKey].position === b.dataset.value));
      }else{
        const cur = state[stateKey].side;
        state[stateKey].side = (cur === val) ? '' : val;
        grid.querySelectorAll('.dir-btn[data-kind="side"]')
            .forEach(b=>b.classList.toggle('active', state[stateKey].side === b.dataset.value));
      }
    });
  });
}


// ===== 状態 =====
const $ = (s) => document.querySelector(s);
const $$ = (s) => Array.from(document.querySelectorAll(s));
const $toast = $('#toast');
const $log = $('#log');

const state = {
  operator: localStorage.getItem('operator') || '',
  mode: localStorage.getItem('mode') || '',
  lastSentAt: 0,
  result: null,
  branch: null,
  mode1: { subtype: '' },   // ★追加
  pre1: { mfNo:'', prodName:'', line:'', position:'', side:'', part:'', defect:'' },
  pre2: { inqNo:'', position:'', side:'', part:'', defect:'', locs:[] ,inspection_count:'' }
};

function toast(msg) { 
  $toast.textContent = msg; 
  $toast.classList.add('show'); 
  setTimeout(() => $toast.classList.remove('show'), 1500); 
}

function log(msg) { 
  const t = new Date().toLocaleTimeString(); 
  $log.textContent = `[${t}] ${msg}\n` + $log.textContent; 
}

function debounceSendGuard() { 
  const now = Date.now(); 
  if(now - state.lastSentAt < CONFIG.SEND_DEBOUNCE_MS) { 
    toast('連続送信ガード（2秒）'); 
    return false; 
  } 
  state.lastSentAt = now; 
  return true; 
}

// ===== UI構築 =====

function ymdToday(){
  const d=new Date(); const pad=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
}
async function fetchSummary(date=ymdToday()){
  const url = CONFIG.DEPLOY_URL + (CONFIG.DEPLOY_URL.includes('?')?'&':'?') + toQuery({
    k: CONFIG.KEY, mode: 'summary', date
  });
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error('HTTP '+res.status);
  const json = await res.json();
  if(!json.ok) throw new Error(json.error||'NG');
  return json;
}
function renderSummary(data){
  const badge = r => r === 'pass' ? '合格'
               : r === 'fail'  ? '不合格'
               : r === 'hold'  ? '保留'
               : r;


  // 合計（group_idユニーク）
  $('#sumTotals').innerHTML =
    `<div><b>今日の件数</b>（group_idユニーク）：<b>${data.totals.groups}</b>　<span style="color:#94a3b8">行数:${data.totals.rows}</span></div>`;

  // 検査者別
  const opHtml = (data.by_operator||[]).map(o=>
    `<li>${o.operator}：<b>${o.groups}</b>件</li>`
  ).join('') || '<li>—</li>';
  $('#sumByOp').innerHTML = `<div><b>検査者別</b></div><ul>${opHtml}</ul>`;

  // 時系列（時刻・種別・合否・検査者）
  const tlHtml = (data.timeline||[]).map(t=>
    `<li>${t.time}　${t.mode}　${badge(t.result)}　${t.operator}</li>`
  ).join('') || '<li>—</li>';
  $('#sumTimeline').innerHTML = `<div><b>時間順の履歴</b></div><ul>${tlHtml}</ul>`;

  $('#sumUpdated').textContent = `更新: ${new Date(data.updatedAt).toLocaleString()}`;
}

async function openSummary(){
  try{
    const data = await fetchSummary();
    renderSummary(data);
    $('#summaryOverlay').classList.remove('hidden');
  }catch(e){
    toast('進捗を取得できません');
  }
}
function closeSummary(){ $('#summaryOverlay').classList.add('hidden'); }
document.getElementById('btnOpenSummary').onclick = openSummary;
document.getElementById('btnCloseSummary').onclick = closeSummary;



function buildOperators() {
  const bar = $('#operatorBar'); 
  bar.innerHTML = '';
  CONFIG.OPERATORS.forEach(op => {
    const b = document.createElement('button'); 
    b.className = 'btn'; 
    b.textContent = op.label; 
    b.dataset.key = op.key;
    if(state.operator === op.key) b.classList.add('active');
    b.onclick = () => { 
      state.operator = op.key; 
      localStorage.setItem('operator', state.operator); 
      $$('#operatorBar .btn').forEach(x => x.classList.remove('active')); 
      b.classList.add('active'); 
    };
    bar.appendChild(b);
  });
}

function buildModes() {
  const grid = $('#modeGrid'); 
  grid.innerHTML = '';
  CONFIG.MODES.forEach(md => {
    const b = document.createElement('button'); 
    b.className = 'btn big'; 
    b.textContent = md.label; 
    b.dataset.key = md.key; 
    if(state.mode === md.key) b.classList.add('active');
    b.onclick = () => { 
      state.mode = md.key; 
      localStorage.setItem('mode', state.mode); 
      $$('#modeGrid .btn').forEach(x => x.classList.remove('active')); 
      b.classList.add('active'); 
      resetFlow();
      // ★ Mode1 のときだけサブ選択UIを表示
const subCard = document.getElementById('mode1SubCard');
if (subCard) {
  if (md.key === '1') {
    subCard.classList.remove('hidden');
    // 既に選ばれている subtype を見た目に反映
    document.querySelectorAll('#mode1SubBar .chip').forEach(ch => {
      ch.classList.toggle('active', ch.dataset.value === (state.mode1?.subtype || ''));
    });
  } else {
    subCard.classList.add('hidden');
  }
}

    // ★ Mode2/Mode3 のときだけ保留を表示
  const holdBtn = document.getElementById('btnHold');
    if (holdBtn) {
    holdBtn.style.display = (md.key === '2' || md.key === '3') ? '' : 'none';
      }
    };
    grid.appendChild(b);
  });
}


function buildParts(gridId) {
  const grid = $(gridId); 
  grid.innerHTML = '';
  CONFIG.PARTS.forEach(part => { 
    const btn = document.createElement('button'); 
    btn.className = 'btn'; 
    btn.textContent = part.label; 
    btn.onclick = () => { 
      $$(gridId + ' .btn').forEach(x => x.classList.remove('active')); 
      btn.classList.add('active'); 
      if(gridId === '#partGrid1') state.pre1.part = part.value; 
      else state.pre2.part = part.value; 
    }; 
    grid.appendChild(btn); 
  });
}

function buildDefects(chipsId) {
  const chips = $(chipsId); 
  chips.innerHTML = '';
  CONFIG.DEFECTS.forEach(d => { 
    const span = document.createElement('span'); 
    span.className = 'chip'; 
    span.textContent = d.label; 
    span.dataset.key = d.key; 
    span.onclick = () => { 
      $$(chipsId + ' .chip').forEach(x => x.classList.remove('active')); 
      span.classList.add('active'); 
      if(chipsId === '#defectChips1') state.pre1.defect = d.key; 
      else state.pre2.defect = d.key; 
    }; 
    chips.appendChild(span); 
  });
}

function wireToggles(posWrapId, sideWrapId, which) {
  const posWrap = $(posWrapId); 
  const sideWrap = $(sideWrapId);
  
  posWrap.querySelectorAll('.chip').forEach(ch => {
    ch.onclick = () => { 
      const v = ch.dataset.position; 
      const cur = (which === 'pre1' ? state.pre1.position : state.pre2.position); 
      const next = (cur === v) ? '' : v; 
      if(which === 'pre1') state.pre1.position = next; 
      else state.pre2.position = next; 
      posWrap.querySelectorAll('.chip').forEach(x => x.classList.toggle('active', x.dataset.position === next)); 
    };
  });
  
  sideWrap.querySelectorAll('.chip').forEach(ch => {
    ch.onclick = () => { 
      const v = ch.dataset.side; 
      const cur = (which === 'pre1' ? state.pre1.side : state.pre2.side); 
      const next = (cur === v) ? '' : v; 
      if(which === 'pre1') state.pre1.side = next; 
      else state.pre2.side = next; 
      sideWrap.querySelectorAll('.chip').forEach(x => x.classList.toggle('active', x.dataset.side === next)); 
    };
  });
}

// ===== 送信 =====
function toQuery(p) { 
  const usp = new URLSearchParams(); 
  Object.entries(p).forEach(([k,v]) => { 
    if(v !== undefined && v !== null && v !== '') usp.append(k, String(v)); 
  }); 
  return usp.toString(); 
}

function makeGroupId() {
  const d = new Date();
  const pad = n => String(n).padStart(2, '0');
  const ts = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  const rnd = Math.random().toString(36).slice(-4).toUpperCase();
  return `G${ts}-${rnd}`;
}

// どこかで使うID生成
function newGroupId(){
  const d=new Date();
  const pad=n=>String(n).padStart(2,'0');
  const ymd = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}`;
  const hms = `${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  const rnd = Math.random().toString(36).slice(-4).toUpperCase();
  return `G${ymd}-${hms}-${rnd}`;
}

// グローバル state に現在の group_id を保持（必要なときだけセット）
state.currentGroupId = '';

// 共通送信ヘルパー（必ず {ok:true} などのJSONを返す）
async function send(p) {
  const url = CONFIG.DEPLOY_URL + (CONFIG.DEPLOY_URL.includes('?') ? '&' : '?') + toQuery(p);
  const r = await fetch(url, { method: 'GET', cache: 'no-store' });

  // 200系でないときは失敗
  if (!r.ok) return { ok: false, error: 'HTTP ' + r.status };

  // JSON を確実に返す（テキスト→JSON フォールバック）
  try {
    const j = await r.json();
    return j && typeof j === 'object' ? j : { ok: false, error: 'bad json' };
  } catch {
    const t = await r.text();
    try { return JSON.parse(t); }
    catch { return { ok: false, error: 'parse error: ' + t.slice(0,120) }; }
  }
}


async function sendSimpleRecord(result) {
  if (!state.operator) return toast('検査者を選んでください');
  if (!state.mode)     return toast('検査種別を選んでください');
  if (!debounceSendGuard()) return;

  const group_id = makeGroupId();
  const isHold   = (result === 'hold');

  const params = {
    k: CONFIG.KEY,
    operator: state.operator,
    mode: state.mode,
    result: result,                                   // ★そのまま送る（failに変換しない）
    fail_seq: (result === 'pass' || isHold) ? '0' : '1', // ★hold=0 / pass=0 / fail=1
    qty: '1',
    group_id,
    subtype: (state.mode === '1' ? (state.mode1?.subtype || '') : '')  // ★追加
  };

  // デバッグログ（暫定）：送る直前の値を確認
  log('OUT ' + JSON.stringify(params));

  // 楽観UI
  toast(isHold ? '保留を記録しました' : '記録しました');
  resetFlow();

  try {
    const res = await send(params);                 // send() は JSON を返す実装に
    const ok = res && (res.ok === true || res.ok === 'true');
    if (!ok) throw new Error(res && res.error ? res.error : 'NG');
  } catch (e) {
    toast('送信失敗：通信環境を確認し再送してください');
    log('送信失敗: ' + (e.message || e));
  }
}



async function sendPre1() {
  if(!state.operator || !state.mode) return toast('検査者/種別を選択');
  if(!debounceSendGuard()) return;

  const {mfNo, prodName, position, side, part, defect} = state.pre1;
  if(!part) return toast('水没箇所（部位）を選択');
  if(!defect) return toast('不良種別を選択');

  const group_id = makeGroupId();
  const params = {
    k: CONFIG.KEY,
    operator: state.operator,
    mode: state.mode,
    result: 'fail',
    mf_no: mfNo,
    product_name: prodName,
    line: state.pre1.line,     // ★ 追加（空でも送られる）
    position, 
    side,
    part,
    detail: defect,
    qty: '1',
    group_id,
    fail_seq: '1',
    subtype: (state.mode === '1' ? (state.mode1?.subtype || '') : '')  // ★追加
  };

  try {
    await send(params);
    toast('記録しました');
    log(`1不合格: ${part}/${defect} / ${group_id}`);
    resetFlow();
  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

function addLoc() {
  const {position, side, part, defect} = state.pre2;
  if(!part) return toast('水没箇所（部位）を選択');
  if(!defect) return toast('不良種別を選択');
  
  state.pre2.locs.push({position, side, part, defect});
  renderLocPreview();
  clearPre2Selection();
  updateSendPre2Button();
}

function clearPre2Selection() {
  state.pre2.position = ''; 
  state.pre2.side = ''; 
  state.pre2.part = ''; 
  state.pre2.defect = '';
  document.querySelectorAll('#posChips2 .chip').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('#sideChips2 .chip').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('#partGrid2 .btn').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('#defectChips2 .chip').forEach(x => x.classList.remove('active'));
}

function removeLoc(index) {
  if(index >= 0 && index < state.pre2.locs.length) {
    state.pre2.locs.splice(index, 1);
    renderLocPreview();
    updateSendPre2Button();
  }
}

function renderLocPreview() {
  const box = $('#locPreview'); 
  box.innerHTML = '';
  
  state.pre2.locs.forEach((loc, i) => {
    const container = document.createElement('div');
    container.className = 'loc-item';
    
    const tag = document.createElement('span');
    tag.className = 'chip active';
    tag.textContent = `#${i + 1} ${(loc.position || '')}/${(loc.side || '')} ${loc.part} / ${loc.defect}`;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = '削除';
    removeBtn.onclick = () => removeLoc(i);
    
    container.appendChild(tag);
    container.appendChild(removeBtn);
    box.appendChild(container);
  });
}

function updateSendPre2Button() {
  const sendBtn = $('#btnSendPre2');
  if(sendBtn) sendBtn.disabled = state.pre2.locs.length === 0;
}

async function sendPre2() {
  if(!state.operator || !state.mode) return toast('検査者/種別を選択');
  if(!debounceSendGuard()) return;
　if(!state.pre2.inqNo){  return toast('問い合わせNo.を入力してください');}
  if(state.pre2.locs.length === 0) return toast('箇所を1つ以上追加してください');

  toast('記録しました');
   resetFlow();

   try {
    const group_id = makeGroupId();
    for(const [idx, loc] of state.pre2.locs.entries()) {
      const params = {
        k: CONFIG.KEY,
        operator: state.operator,
        mode: state.mode,
        result: 'fail',
        reason: 'same',
        inquiry_no: state.pre2.inqNo,
        index: String(idx + 1),
        position: loc.position,
        side: loc.side,
        part: loc.part,
        detail: loc.defect,
        inspection_count: state.pre2.inspection_count || '',  // ★追加
        qty: '1',
        group_id,
        fail_seq: String(idx + 1)
      };
      await send(params);
    }
 
    log(`2同箇所 不合格 ${state.pre2.locs.length}件 / ${group_id}`);

  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

// ===== フロー制御 =====
function resetFlow() {
  $('#branchCard').classList.add('hidden');
  $('#preProductFailCard').classList.add('hidden');
  $('#preRepairSameCard').classList.add('hidden');
  state.result = null; 
  state.branch = null; 
  resetDetails();
}

function resetDetails() {
  state.pre1 = { mfNo:'', prodName:'', position:'', side:'', part:'', defect:'' };
  state.pre2 = { inqNo:'', position:'', side:'', part:'', defect:'', locs:[] };

  // フォームのリセット（要素がある時だけ）
  const mf = $('#mfNo');      if (mf) mf.value = '';
  const pn = $('#prodName');  if (pn) pn.value = '';
  const iq = $('#inqNo');     if (iq) iq.value = '';

  // ★複数要素は $$ で取得して forEach
  $$('.chip').forEach(x => x.classList.remove('active'));
  $$('.btn').forEach(x => x.classList.remove('active'));

  const lp = $('#locPreview'); if (lp) lp.innerHTML = '';
  updateSendPre2Button && updateSendPre2Button();

  // ★今の state に合わせて選択表示を戻す
  refreshActiveUI();
}


function handlePass() { 
  sendSimpleRecord('pass'); 
}


function chooseBranch(which) {
  state.branch = which; 
  ['btnSame', 'btnDiff', 'btnComplex'].forEach(id => $('#' + id).classList.remove('active'));
  
  if(which === 'same') {
    $('#btnSame').classList.add('active');
    $('#btnBranchSend').classList.add('hidden');
    $('#preRepairSameCard').classList.remove('hidden');
  } else {
    if(which === 'diff') $('#btnDiff').classList.add('active');
    if(which === 'complex') $('#btnComplex').classList.add('active');
    $('#btnBranchSend').classList.remove('hidden');
    $('#preRepairSameCard').classList.add('hidden');
  }
}

async function sendBranch() {
  if(!state.operator || !state.mode || !state.branch) return toast('条件不足');
  if(!debounceSendGuard()) return;

  const group_id = makeGroupId();
  const params = {
    k: CONFIG.KEY,
    operator: state.operator,
    mode: state.mode,
    result: 'fail',
    reason: state.branch,
    qty: '1',
    group_id,
    fail_seq: '1',
    inspection_count: state.pre2.inspection_count || ''  // ★追加
  };

  try {
    await send(params);
    toast('記録しました');
    log(`2不合格: ${state.branch} / ${group_id}`);
    try {
      resetFlow();
    } catch(resetError) {
      console.warn('リセット処理でエラー:', resetError);
    }
  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

function wirePressFeedback(selector){
  const el = document.querySelector(selector);
  if(!el) return;
  const onDown = ()=> el.classList.add('active');
  const onUp   = ()=> el.classList.remove('active');
  el.addEventListener('pointerdown',  onDown);
  el.addEventListener('pointerup',    onUp);
  el.addEventListener('pointercancel',onUp);
  el.addEventListener('pointerleave', onUp);
}

// iOSで :active を有効にするおまじない（必須）
document.addEventListener('touchstart', ()=>{}, {passive:true});

// スクロール親を探す
function getScrollableParent(el){
  let p = el.parentElement;
  while (p) {
    const style = getComputedStyle(p);
    const canScroll = /(auto|scroll)/.test(style.overflowY) && p.scrollHeight > p.clientHeight;
    if (canScroll) return p;
    p = p.parentElement;
  }
  // なければドキュメントを使う
  return document.scrollingElement || document.documentElement;
}

// イージング（加速→減速）
function easeInOutCubic(t){ return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

// ウィンドウ基準で“するっ”とスクロール（offset: 上に残す余白px）
function scrollIntoViewSmooth(el, duration = 600, offset = 0){
  if(!el) return;
  const startY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  const rect   = el.getBoundingClientRect();
  const targetY = startY + rect.top - offset;

  const delta = targetY - startY;
  if (Math.abs(delta) < 2) return;

  const t0 = performance.now();
  function frame(now){
    const t = Math.min(1, (now - t0) / duration);
    const eased = easeInOutCubic(t);
    window.scrollTo(0, startY + delta * eased);
    if (t < 1) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

// 要素を表示→次フレームでターゲットへ確実にスクロール（入力欄ならフォーカス）
function showAndScroll(containerEl, targetEl = null, offset = 120, duration = 600){
  if(!containerEl) return;
  containerEl.classList.remove('hidden');
  // レイアウト確定を2フレーム待つ
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    const el = targetEl || containerEl;
    // iPadでキーボードを出す前に位置決めしたいので、preventScroll で先にフォーカスだけ
    if (el.tagName === 'INPUT') { try{ el.focus({preventScroll:true}); }catch{} }
    scrollIntoViewSmooth(el, duration, offset);
  }));
}



// ===== 初期化 =====
function init() {

  installPressFeedback(); 

  try {
    buildOperators();
    buildModes();
    buildParts('#partGrid1'); 
    buildDefects('#defectChips1'); 
    buildParts('#partGrid2'); 
    buildDefects('#defectChips2'); 

    // イベントリスナー（要素の存在チェック付き）
    const mfNoInput = $('#mfNo');
    const prodNameInput = $('#prodName');
    const inqNoInput = $('#inqNo');
    const inspectionCountInput = $('#inspectionCount');
if (inspectionCountInput) {
  inspectionCountInput.addEventListener('input', e => {
    state.pre2.inspection_count = e.target.value.trim();
  });
}

// ★ Mode1 サブ選択（PP / 受け入れ検品）
const subPP = document.getElementById('subPP');
const subAccept = document.getElementById('subAccept');
[subPP, subAccept].forEach(btn=>{
  if(!btn) return;
  btn.onclick = () => {
    const val = btn.dataset.value;             // "PP" or "ACCEPT"
    state.mode1.subtype = (state.mode1.subtype === val) ? '' : val; // 2回押しで解除
    // 見た目更新
    document.querySelectorAll('#mode1SubBar .chip').forEach(ch => {
      ch.classList.toggle('active', ch.dataset.value === state.mode1.subtype);
    });
  };
});


    const btnPrefillA = document.getElementById('btnPrefillA');
if (btnPrefillA) {
  btnPrefillA.onclick = () => {
    const input = document.getElementById('inqNo');
    if (!input) return;
    // 先頭を必ず A1.../123... の形に（重複Aを避ける）
    const raw = input.value.trim().toUpperCase();
    input.value = raw.startsWith('A') ? raw : ('A' + raw.replace(/^A/, ''));
    // フォーカス＆カーソル末尾へ
    input.focus({ preventScroll: true });
    try { const p = input.value.length; input.setSelectionRange(p, p); } catch {}
    // state も即時同期（既存の input イベントがあればそれでOK）
    input.dispatchEvent(new Event('input', { bubbles: true }));
  };
}

    const btnPass = $('#btnPass');
    const btnFail = $('#btnFail');
    const btnSame = $('#btnSame');
    const btnDiff = $('#btnDiff');
    const btnComplex = $('#btnComplex');
    const btnBranchSend = $('#btnBranchSend');
    const btnSendPre1 = $('#btnSendPre1');
    const btnAddLoc = $('#btnAddLoc');
    const btnSendPre2 = $('#btnSendPre2');

    // ★ 保留ボタン（Mode3専用）
    const btnHold = $('#btnHold');
if (btnHold) {
  btnHold.onclick = () => {
    if (!state.operator) return toast('検査者を選択');
    if (!state.mode)     return toast('検査種別を選択');
    if (state.mode !== '2' && state.mode !== '3') return toast('保留はMode2/3のみ');

   // （任意）Mode2で分岐UIを開いていた場合は畳んでおく
   document.getElementById('branchCard')?.classList.add('hidden');
   document.getElementById('preRepairSameCard')?.classList.add('hidden');

    // 即送信（result=hold / fail_seq=0 は sendSimpleRecord 側で処理）
    sendSimpleRecord('hold');
  };
}



bindLine('#lineChips1', 'pre1');


// 不合格：modeごとの分岐（スクロール込み）
// 不合格：modeごとの分岐（スムーススクロール）
function handleFail(){
  if (!state.operator) return toast('検査者を選択');
  if (!state.mode)     return toast('検査種別を選択');

  switch (state.mode) {
    case '1': { // 出荷前製品 → 詳細入力カードへ
      const card1 = document.getElementById('preProductFailCard');
      showAndScroll(card1, card1, 80, 600);
      break;
    }
    case '2': { // 出荷前修理 → 分岐カードへ
      const branch = document.getElementById('branchCard');
      showAndScroll(branch, branch, 80, 600);
      break;
    }
    default: { // 3/4 → 即送信
      sendSimpleRecord('fail');
      break;
    }
  }
}


    if(mfNoInput) mfNoInput.addEventListener('input', e => state.pre1.mfNo = e.target.value.trim());
    if(prodNameInput) prodNameInput.addEventListener('input', e => state.pre1.prodName = e.target.value.trim());
    if(inqNoInput) inqNoInput.addEventListener('input', e => state.pre2.inqNo = e.target.value.trim().toUpperCase());

    if(btnPass) btnPass.onclick = handlePass;
    if(btnFail) btnFail.onclick = handleFail;

if(btnSame) btnSame.onclick = () => {
  chooseBranch('same');
  const sameCard = document.getElementById('preRepairSameCard');
  sameCard.classList.remove('hidden');

  // 問い合わせNo.入力欄をターゲットにスクロール
  const inq = document.getElementById('inqNo');
  if (inq) {
    showAndScroll(sameCard, inq, 150, 600); 
  }
};



    if(btnDiff) btnDiff.onclick = () => chooseBranch('diff');
    if(btnComplex) btnComplex.onclick = () => chooseBranch('complex');
    if(btnBranchSend) btnBranchSend.onclick = sendBranch;

    if(btnSendPre1) btnSendPre1.onclick = sendPre1;
    if(btnAddLoc) btnAddLoc.onclick = addLoc;
    if(btnSendPre2) btnSendPre2.onclick = sendPre2;
    

 bindDirGrid('#dirGrid1', 'pre1');
  bindDirGrid('#dirGrid2', 'pre2');


    // 初期状態設定
    updateSendPre2Button();
  } catch(error) {
    console.error('初期化エラー:', error);
  }
}

// 確実な初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

function refreshActiveUI(){
  // 検査者
  const opKeys = CONFIG.OPERATORS.map(o => o.key);
  $$('#operatorBar .btn').forEach((el, i) => {
    const key = opKeys[i];
    el.classList.toggle('active', state.operator === key);
  });

  // 検査種別
  const modeKeys = CONFIG.MODES.map(m => m.key);
  $$('#modeGrid .btn').forEach((el, i) => {
    const key = modeKeys[i];
    el.classList.toggle('active', state.mode === key);
  });
}

function bindLine(selector, stateKey){
  const box = document.querySelector(selector);
  if(!box) return;
  box.querySelectorAll('.chip').forEach(ch=>{
    ch.addEventListener('click', ()=>{
      const val = ch.dataset.line;
      // 2回押しで解除（不要ならトグル外して常に選択でもOK）
      if (state[stateKey].line === val) {
        state[stateKey].line = '';
        ch.classList.remove('active');
      } else {
        state[stateKey].line = val;
        box.querySelectorAll('.chip').forEach(x=>x.classList.remove('active'));
        ch.classList.add('active');
      }
    });
  });
}


</script>
</body>
</html>