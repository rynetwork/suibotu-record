<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>水没検査 入力パネル（修正版）</title>
<style>
:root{
--bg:#0f172a;--card:#111827;--muted:#94a3b8;--ok:#16a34a;--warn:#f59e0b;--err:#ef4444;--ink:#e5e7eb;--accent:#22d3ee;
--font-size-base:20px;
--font-size-large:28px;
--btn-padding:20px 24px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;background:linear-gradient(160deg,#0b1222,#0f172a 40%,#0c1226);color:var(--ink);font-size:var(--font-size-base)}
.wrap{max-width:1100px;margin:0 auto;padding:20px}
header{display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin-bottom:16px}
header h1{font-size:var(--font-size-large);margin:0 8px 0 0;font-weight:800;letter-spacing:.02em}
.card{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:18px;box-shadow:0 10px 24px rgba(0,0,0,.25)}
.section-title{font-weight:800;margin:8px 2px 12px;color:#cbd5e1;font-size:var(--font-size-base)}
.row{display:flex;gap:14px;flex-wrap:wrap}
.grid{display:grid;grid-template-columns:repeat(4,minmax(150px,1fr));gap:14px}
@media (max-width:900px){.grid{grid-template-columns:repeat(2,minmax(150px,1fr))}}
.btn{border:1px solid #1f2937;background:#0b1222;color:var(--ink);border-radius:14px;padding:var(--btn-padding);font-weight:800;cursor:pointer;letter-spacing:.02em;font-size:var(--font-size-base)}
.btn.big{height:100px;font-size:var(--font-size-large);border-radius:16px;background:linear-gradient(180deg,#0f1b33,#0a1326);box-shadow:inset 0 0 0 1px rgba(255,255,255,.04),0 8px 20px rgba(0,0,0,.2)}
.btn:disabled{opacity:.5;cursor:not-allowed}
.btn.active {
  background: #1e40af;  /* 濃い青 */
  border-color: #60a5fa;
}

.btn.ok{background:#052e1a;border-color:#14532d}
.btn.err{background:#3b0a0a;border-color:#7f1d1d}
.pill{display:inline-flex;align-items:center;gap:8px;background:#0b1222;border:1px solid #233046;color:var(--ink);padding:12px 14px;border-radius:999px;font-size:var(--font-size-base)}
.pill input,.pill select{background:transparent;border:none;color:var(--ink);outline:none;font-size:var(--font-size-base);min-width:120px}
.chips{display:flex;flex-wrap:wrap;gap:10px}
.chip{border:1px solid #233046;border-radius:999px;padding:14px 18px;background:#0b1222;color:var(--ink);cursor:pointer;font-weight:700;font-size:var(--font-size-base)}
.chip.active{border-color:#2aa6c8;background:#0e1a2c}
.muted{color:var(--muted);font-size:18px}
.log{margin-top:14px;font-size:16px;color:var(--muted);max-height:180px;overflow:auto;white-space:pre-wrap}
.toast{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(2,6,23,.95);border:2px solid #ef4444;color:#fff;padding:20px 24px;border-radius:16px;box-shadow:0 12px 26px rgba(0,0,0,.45);opacity:0;transition:.3s;font-size:var(--font-size-large);font-weight:800;text-align:center;z-index:1000}
.toast.show{opacity:1}
.toast{ pointer-events:none; }
input[type="text"], input[type="number"], input[type="search"]{background:#0b1222;border:1px solid #233046;color:#fff;border-radius:12px;padding:12px 14px;font-size:var(--font-size-base)}
.divider{height:14px}
.hidden{display:none}
.kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0b1222;border:1px solid #233046;border-radius:6px;padding:4px 8px;font-size:16px}

/* 検査者ボタンを3等分 */
#operatorBar{display:grid;grid-template-columns:repeat(3,1fr);gap:14px;width:100%}
#operatorBar .btn{width:100%;text-align:center}

/* ロケーション削除ボタンスタイル */
.loc-item {
  display: flex;
  align-items: center;
  gap: 8px;
}
.remove-btn {
  background: var(--err);
  border: 1px solid #7f1d1d;
  color: white;
  border-radius: 6px;
  padding: 4px 8px;
  font-size: 14px;
  cursor: pointer;
}
.btn{ -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

/* タップ/クリック直後の一瞬のフィードバック */
.btn:active {
  background:#1e40af;          /* 目立つ色に調整可 */
  border-color:#60a5fa;
  transform: translateY(1px);  /* 押し込み感 */
}
/* iOS向けのタップ最適化（任意） */
.btn { -webkit-tap-highlight-color: transparent; touch-action: manipulation; }

/* 問い合わせNo.を画面上端から少し下に止める */
#inqNo { scroll-margin-top: 120px; }



</style>
</head>
<body>
<div class="wrap">
<header>
<h1>水没検査 入力パネル</h1>
<span class="muted">（検査者 → 種別 → 合否 → 分岐）</span>
</header>

<!-- 検査者 -->
<section class="card" aria-label="検査者">
<div class="section-title">検査者</div>
<div class="row" id="operatorBar"></div>
<div class="muted" style="margin-top:6px">※ 作業者が変わったら別のボタンを押して切替。構成の変更は <span class="kbd">CONFIG.OPERATORS</span> を編集。</div>
</section>

<div class="divider"></div>

<!-- 種別 -->
<section class="card" aria-label="種別">
  <div class="section-title">検査種別</div>
  <div class="grid" id="modeGrid"></div>
</section>

<div class="divider"></div>

<!-- 合否 -->
<section class="card" aria-label="合否">
  <div class="section-title">合否</div>
  <div class="row">
    <button class="btn ok" id="btnPass">合格</button>
    <button class="btn err" id="btnFail">不合格</button>
  </div>
  <div class="muted" style="margin-top:6px">※ 合格は即記録（2秒の連打ガード）。</div>
</section>

<div class="divider"></div>

<!-- 分岐（2:出荷前修理の不合格時） -->
<section class="card hidden" id="branchCard" aria-label="不合格分岐">
  <div class="section-title">不合格（出荷前修理）</div>
  <div class="row">
    <button class="btn" data-reason="same" id="btnSame">1 同箇所</button>
    <button class="btn" data-reason="diff" id="btnDiff">2 別箇所</button>
    <button class="btn" data-reason="complex" id="btnComplex">3 同別複合</button>
  </div>
  <div class="row" style="margin-top:10px">
    <button class="btn ok hidden" id="btnBranchSend">送信（分岐結果）</button>
  </div>
</section>

<div class="divider"></div>

<!-- 1:出荷前製品 不合格時の詳細入力 -->
<section class="card hidden" id="preProductFailCard" aria-label="出荷前製品・不合格 詳細">
  <div class="section-title">出荷前製品・不合格 詳細</div>
  <div class="row">
    <label class="pill">製造No.
      <input id="mfNo" type="text" placeholder="例) 123456" inputmode="numeric" pattern="[0-9]{6}" />
    </label>
    <label class="pill">品名（音声入力可）
      <input id="prodName" type="text" placeholder="例) 5×4 セミドライ" />
    </label>
  </div>
  <div class="row" style="margin-top:8px">
    <div class="chips" id="posChips">
      <span class="chip" data-position="front">前</span>
      <span class="chip" data-position="back">後</span>
    </div>
    <div class="chips" id="sideChips">
      <span class="chip" data-side="L">左</span>
      <span class="chip" data-side="R">右</span>
    </div>
  </div>
  <div class="section-title" style="margin-top:10px">水没箇所（必須）</div>
  <div class="grid" id="partGrid1"></div>
  <div class="section-title" style="margin-top:10px">不良種別（必須）</div>
  <div class="chips" id="defectChips1"></div>
  <div class="row" style="margin-top:14px">
    <button class="btn ok" id="btnSendPre1">送信</button>
  </div>
</section>

<div class="divider"></div>

<!-- 2:出荷前修理 不合格=同箇所 詳細（複数箇所の繰り返し） -->
<section class="card hidden" id="preRepairSameCard" aria-label="出荷前修理 同箇所 詳細">
  <div class="section-title">出荷前修理・同箇所 詳細入力</div>
<div class="card" style="margin:12px 0; padding:24px; text-align:center; background:#222; border:2px solid #4ade80;">
  <div class="section-title" style="font-size:24px; margin-bottom:12px; color:#4ade80;">問い合わせNo.（必須）</div>
  <input id="inqNo" type="text"
         placeholder="A123456 または 123456"
         inputmode="latin-prose"
         pattern="A?[0-9]{6}"
         style="font-size:28px; padding:12px 16px; width:90%; max-width:400px;
                border-radius:8px; border:none; text-align:center;
                background:#0b1222; color:#fff;" />
</div>

  <div class="row" style="margin-top:8px">
    <div class="chips" id="posChips2">
      <span class="chip" data-position="front">前</span>
      <span class="chip" data-position="back">後</span>
    </div>
    <div class="chips" id="sideChips2">
      <span class="chip" data-side="L">左</span>
      <span class="chip" data-side="R">右</span>
    </div>
  </div>
  <div class="section-title" style="margin-top:10px">水没箇所（必須）</div>
  <div class="grid" id="partGrid2"></div>
  <div class="section-title" style="margin-top:10px">不良種別（必須）</div>
  <div class="chips" id="defectChips2"></div>
  <div class="row" style="margin-top:12px">
    <button class="btn" id="btnAddLoc">＋ 箇所を追加</button>
  </div>
  <div class="muted" style="margin-top:8px">※ 追加を押すと現在の選択が保存されます。削除も可能です。</div>
  <div class="row" id="locPreview" style="margin-top:8px"></div>
  <div class="row" style="margin-top:10px">
    <button class="btn ok" id="btnSendPre2" disabled>送信（保存した箇所を登録）</button>
  </div>
</section>

<div class="log" id="log"></div>
</div>
<div class="toast" id="toast"></div>

<script>
// ===== 設定 =====
const CONFIG = {
  DEPLOY_URL: "https://script.google.com/macros/s/AKfycbw1oNqiniXD9MUdca7uv2GAf-AoZs8Z5xEshgBiMbUtvJ5tq7LfHj4UG8w9gedh03uy/exec",
  KEY: "KEY_2025_SUIKEN",
  OPERATORS: [
    {key:'松川(将)', label:'松川'},
    {key:'千葉(英)', label:'千葉'},
    {key:'高橋(未)', label:'高橋'}
  ],
  MODES: [
    {key:'1', label:'1 出荷前製品'},
    {key:'2', label:'2 出荷前修理品'},
    {key:'3', label:'3 初回修理品'},
    {key:'4', label:'4 初回修理品 裏検査'}
  ],
  PARTS: [
    { value: 'アンクル', label: 'アンクル' },
    { value: '腕', label: '腕(ウデ)' },
    { value: '肩', label: '肩(カタ)' },
    { value: 'グローブ', label: 'グローブ' },
    { value: '腰', label: '腰(コシ)' },
    { value: '背中', label: '背中(セナカ)' },
    { value: '袖口', label: '袖口(ソデグチ)' },
    { value: 'ソックス部ジョイント', label: 'ソックス部ジョイント' },
    { value: 'ソックス部本体', label: 'ソックス部本体' },
    { value: 'スネ', label: 'スネ' },
    { value: '尻', label: '尻(シリ)' },
    { value: '胸', label: '胸(ムネ)' },
    { value: 'ネック', label: 'ネック' },
    { value: '膝上', label: '膝上(ヒザウエ)' },
    { value: '膝裏', label: '膝裏(ヒザウラ)' },
    { value: '腹', label: '腹(ハラ)' },
    { value: 'パッド', label: 'パッド' },
    { value: 'ファスナー部', label: 'ファスナー部' },
    { value: 'フクラハギ', label: 'フクラハギ' },
    { value: '前股', label: '前股(マエマタ)' },
    { value: '後ろ股', label: '後ろ股(ウシロマタ)' },
    { value: '腿', label: '腿(モモ)' },
    { value: '腿裏', label: '腿裏(モモウラ)' },
    { value: '脇', label: '脇(ワキ)' },
    { value: 'リスト', label: 'リスト' }
  ],
  DEFECTS: [
    {key:'pinhole', label:'ピンホール'},
    {key:'seam', label:'接合部'},
    {key:'tape', label:'テープ'}
  ],
  SEND_DEBOUNCE_MS: 2000
};

// ===== 状態 =====
const $ = (s) => document.querySelector(s);
const $$ = (s) => Array.from(document.querySelectorAll(s));
const $toast = $('#toast');
const $log = $('#log');

const state = {
  operator: localStorage.getItem('operator') || '',
  mode: localStorage.getItem('mode') || '',
  lastSentAt: 0,
  result: null,
  branch: null,
  pre1: { mfNo:'', prodName:'', position:'', side:'', part:'', defect:'' },
  pre2: { inqNo:'', position:'', side:'', part:'', defect:'', locs:[] }
};

function toast(msg) { 
  $toast.textContent = msg; 
  $toast.classList.add('show'); 
  setTimeout(() => $toast.classList.remove('show'), 1500); 
}

function log(msg) { 
  const t = new Date().toLocaleTimeString(); 
  $log.textContent = `[${t}] ${msg}\n` + $log.textContent; 
}

function debounceSendGuard() { 
  const now = Date.now(); 
  if(now - state.lastSentAt < CONFIG.SEND_DEBOUNCE_MS) { 
    toast('連続送信ガード（2秒）'); 
    return false; 
  } 
  state.lastSentAt = now; 
  return true; 
}

// ===== UI構築 =====
function buildOperators() {
  const bar = $('#operatorBar'); 
  bar.innerHTML = '';
  CONFIG.OPERATORS.forEach(op => {
    const b = document.createElement('button'); 
    b.className = 'btn'; 
    b.textContent = op.label; 
    b.dataset.key = op.key;
    if(state.operator === op.key) b.classList.add('active');
    b.onclick = () => { 
      state.operator = op.key; 
      localStorage.setItem('operator', state.operator); 
      $$('#operatorBar .btn').forEach(x => x.classList.remove('active')); 
      b.classList.add('active'); 
    };
    bar.appendChild(b);
  });
}

function buildModes() {
  const grid = $('#modeGrid'); 
  grid.innerHTML = '';
  CONFIG.MODES.forEach(md => {
    const b = document.createElement('button'); 
    b.className = 'btn big'; 
    b.textContent = md.label; 
    b.dataset.key = md.key; 
    if(state.mode === md.key) b.classList.add('active');
    b.onclick = () => { 
      state.mode = md.key; 
      localStorage.setItem('mode', state.mode); 
      $$('#modeGrid .btn').forEach(x => x.classList.remove('active')); 
      b.classList.add('active'); 
      resetFlow(); 
    };
    grid.appendChild(b);
  });
}

function buildParts(gridId) {
  const grid = $(gridId); 
  grid.innerHTML = '';
  CONFIG.PARTS.forEach(part => { 
    const btn = document.createElement('button'); 
    btn.className = 'btn'; 
    btn.textContent = part.label; 
    btn.onclick = () => { 
      $$(gridId + ' .btn').forEach(x => x.classList.remove('active')); 
      btn.classList.add('active'); 
      if(gridId === '#partGrid1') state.pre1.part = part.value; 
      else state.pre2.part = part.value; 
    }; 
    grid.appendChild(btn); 
  });
}

function buildDefects(chipsId) {
  const chips = $(chipsId); 
  chips.innerHTML = '';
  CONFIG.DEFECTS.forEach(d => { 
    const span = document.createElement('span'); 
    span.className = 'chip'; 
    span.textContent = d.label; 
    span.dataset.key = d.key; 
    span.onclick = () => { 
      $$(chipsId + ' .chip').forEach(x => x.classList.remove('active')); 
      span.classList.add('active'); 
      if(chipsId === '#defectChips1') state.pre1.defect = d.key; 
      else state.pre2.defect = d.key; 
    }; 
    chips.appendChild(span); 
  });
}

function wireToggles(posWrapId, sideWrapId, which) {
  const posWrap = $(posWrapId); 
  const sideWrap = $(sideWrapId);
  
  posWrap.querySelectorAll('.chip').forEach(ch => {
    ch.onclick = () => { 
      const v = ch.dataset.position; 
      const cur = (which === 'pre1' ? state.pre1.position : state.pre2.position); 
      const next = (cur === v) ? '' : v; 
      if(which === 'pre1') state.pre1.position = next; 
      else state.pre2.position = next; 
      posWrap.querySelectorAll('.chip').forEach(x => x.classList.toggle('active', x.dataset.position === next)); 
    };
  });
  
  sideWrap.querySelectorAll('.chip').forEach(ch => {
    ch.onclick = () => { 
      const v = ch.dataset.side; 
      const cur = (which === 'pre1' ? state.pre1.side : state.pre2.side); 
      const next = (cur === v) ? '' : v; 
      if(which === 'pre1') state.pre1.side = next; 
      else state.pre2.side = next; 
      sideWrap.querySelectorAll('.chip').forEach(x => x.classList.toggle('active', x.dataset.side === next)); 
    };
  });
}

// ===== 送信 =====
function toQuery(p) { 
  const usp = new URLSearchParams(); 
  Object.entries(p).forEach(([k,v]) => { 
    if(v !== undefined && v !== null && v !== '') usp.append(k, String(v)); 
  }); 
  return usp.toString(); 
}

function makeGroupId() {
  const d = new Date();
  const pad = n => String(n).padStart(2, '0');
  const ts = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  const rnd = Math.random().toString(36).slice(-4).toUpperCase();
  return `G${ts}-${rnd}`;
}

async function send(params) { 
  const url = CONFIG.DEPLOY_URL + (CONFIG.DEPLOY_URL.includes('?') ? '&' : '?') + toQuery(params); 
  const res = await fetch(url, {method:'GET', cache:'no-store'}); 
  if(!res.ok) throw new Error('HTTP ' + res.status); 
  const json = await res.json().catch(() => ({ok:false})); 
  if(!json.ok) throw new Error('NG'); 
}

async function sendSimpleRecord(result) {
  if(!state.operator) return toast('検査者を選んでください');
  if(!state.mode) return toast('検査種別を選んでください');
  if(!debounceSendGuard()) return;

  const group_id = makeGroupId();
  const params = {
    k: CONFIG.KEY,
    operator: state.operator,
    mode: state.mode,
    result,
    qty: '1',
    group_id,
    fail_seq: (result === 'pass' ? '0' : '1')
  };

  try {
    await send(params);
    toast('記録しました');
    log(`mode:${state.mode} / ${result} / ${group_id}`);
    resetFlow();
  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

async function sendPre1() {
  if(!state.operator || !state.mode) return toast('検査者/種別を選択');
  if(!debounceSendGuard()) return;

  const {mfNo, prodName, position, side, part, defect} = state.pre1;
  if(!part) return toast('水没箇所（部位）を選択');
  if(!defect) return toast('不良種別を選択');

  const group_id = makeGroupId();
  const params = {
    k: CONFIG.KEY,
    operator: state.operator,
    mode: state.mode,
    result: 'fail',
    mf_no: mfNo,
    product_name: prodName,
    position, 
    side,
    part,
    detail: defect,
    qty: '1',
    group_id,
    fail_seq: '1'
  };

  try {
    await send(params);
    toast('記録しました');
    log(`1不合格: ${part}/${defect} / ${group_id}`);
    resetFlow();
  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

function addLoc() {
  const {position, side, part, defect} = state.pre2;
  if(!part) return toast('水没箇所（部位）を選択');
  if(!defect) return toast('不良種別を選択');
  
  state.pre2.locs.push({position, side, part, defect});
  renderLocPreview();
  clearPre2Selection();
  updateSendPre2Button();
}

function clearPre2Selection() {
  state.pre2.position = ''; 
  state.pre2.side = ''; 
  state.pre2.part = ''; 
  state.pre2.defect = '';
  document.querySelectorAll('#posChips2 .chip').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('#sideChips2 .chip').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('#partGrid2 .btn').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('#defectChips2 .chip').forEach(x => x.classList.remove('active'));
}

function removeLoc(index) {
  if(index >= 0 && index < state.pre2.locs.length) {
    state.pre2.locs.splice(index, 1);
    renderLocPreview();
    updateSendPre2Button();
  }
}

function renderLocPreview() {
  const box = $('#locPreview'); 
  box.innerHTML = '';
  
  state.pre2.locs.forEach((loc, i) => {
    const container = document.createElement('div');
    container.className = 'loc-item';
    
    const tag = document.createElement('span');
    tag.className = 'chip active';
    tag.textContent = `#${i + 1} ${(loc.position || '')}/${(loc.side || '')} ${loc.part} / ${loc.defect}`;
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = '削除';
    removeBtn.onclick = () => removeLoc(i);
    
    container.appendChild(tag);
    container.appendChild(removeBtn);
    box.appendChild(container);
  });
}

function updateSendPre2Button() {
  const sendBtn = $('#btnSendPre2');
  if(sendBtn) sendBtn.disabled = state.pre2.locs.length === 0;
}

async function sendPre2() {
  if(!state.operator || !state.mode) return toast('検査者/種別を選択');
  if(!debounceSendGuard()) return;
  if(!state.pre2.inqNo || !/^A?\d{6}$/.test(state.pre2.inqNo)) return toast('問い合わせNo.を確認');
  if(state.pre2.locs.length === 0) return toast('箇所を1つ以上追加してください');

  try {
    const group_id = makeGroupId();
    for(const [idx, loc] of state.pre2.locs.entries()) {
      const params = {
        k: CONFIG.KEY,
        operator: state.operator,
        mode: state.mode,
        result: 'fail',
        reason: 'same',
        inquiry_no: state.pre2.inqNo,
        index: String(idx + 1),
        position: loc.position,
        side: loc.side,
        part: loc.part,
        detail: loc.defect,
        qty: '1',
        group_id,
        fail_seq: String(idx + 1)
      };
      await send(params);
    }
    toast('記録しました');
    log(`2同箇所 不合格 ${state.pre2.locs.length}件 / ${group_id}`);
    resetFlow();
  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

// ===== フロー制御 =====
function resetFlow() {
  $('#branchCard').classList.add('hidden');
  $('#preProductFailCard').classList.add('hidden');
  $('#preRepairSameCard').classList.add('hidden');
  state.result = null; 
  state.branch = null; 
  resetDetails();
}

function resetDetails() {
  state.pre1 = { mfNo:'', prodName:'', position:'', side:'', part:'', defect:'' };
  state.pre2 = { inqNo:'', position:'', side:'', part:'', defect:'', locs:[] };

  // フォームのリセット（要素がある時だけ）
  const mf = $('#mfNo');      if (mf) mf.value = '';
  const pn = $('#prodName');  if (pn) pn.value = '';
  const iq = $('#inqNo');     if (iq) iq.value = '';

  // ★複数要素は $$ で取得して forEach
  $$('.chip').forEach(x => x.classList.remove('active'));
  $$('.btn').forEach(x => x.classList.remove('active'));

  const lp = $('#locPreview'); if (lp) lp.innerHTML = '';
  updateSendPre2Button && updateSendPre2Button();

  // ★今の state に合わせて選択表示を戻す
  refreshActiveUI();
}


function handlePass() { 
  sendSimpleRecord('pass'); 
}


function chooseBranch(which) {
  state.branch = which; 
  ['btnSame', 'btnDiff', 'btnComplex'].forEach(id => $('#' + id).classList.remove('active'));
  
  if(which === 'same') {
    $('#btnSame').classList.add('active');
    $('#btnBranchSend').classList.add('hidden');
    $('#preRepairSameCard').classList.remove('hidden');
  } else {
    if(which === 'diff') $('#btnDiff').classList.add('active');
    if(which === 'complex') $('#btnComplex').classList.add('active');
    $('#btnBranchSend').classList.remove('hidden');
    $('#preRepairSameCard').classList.add('hidden');
  }
}

async function sendBranch() {
  if(!state.operator || !state.mode || !state.branch) return toast('条件不足');
  if(!debounceSendGuard()) return;

  const group_id = makeGroupId();
  const params = {
    k: CONFIG.KEY,
    operator: state.operator,
    mode: state.mode,
    result: 'fail',
    reason: state.branch,
    qty: '1',
    group_id,
    fail_seq: '1'
  };

  try {
    await send(params);
    toast('記録しました');
    log(`2不合格: ${state.branch} / ${group_id}`);
    try {
      resetFlow();
    } catch(resetError) {
      console.warn('リセット処理でエラー:', resetError);
    }
  } catch(e) {
    toast('送信失敗'); 
    log('送信失敗: ' + e.message);
  }
}

function wirePressFeedback(selector){
  const el = document.querySelector(selector);
  if(!el) return;
  const onDown = ()=> el.classList.add('active');
  const onUp   = ()=> el.classList.remove('active');
  el.addEventListener('pointerdown',  onDown);
  el.addEventListener('pointerup',    onUp);
  el.addEventListener('pointercancel',onUp);
  el.addEventListener('pointerleave', onUp);
}

// iOSで :active を有効にするおまじない（必須）
document.addEventListener('touchstart', ()=>{}, {passive:true});

// スクロール親を探す
function getScrollableParent(el){
  let p = el.parentElement;
  while (p) {
    const style = getComputedStyle(p);
    const canScroll = /(auto|scroll)/.test(style.overflowY) && p.scrollHeight > p.clientHeight;
    if (canScroll) return p;
    p = p.parentElement;
  }
  // なければドキュメントを使う
  return document.scrollingElement || document.documentElement;
}

// イージング（加速→減速）
function easeInOutCubic(t){ return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

// ウィンドウ基準で“するっ”とスクロール（offset: 上に残す余白px）
function scrollIntoViewSmooth(el, duration = 600, offset = 0){
  if(!el) return;
  const startY = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  const rect   = el.getBoundingClientRect();
  const targetY = startY + rect.top - offset;

  const delta = targetY - startY;
  if (Math.abs(delta) < 2) return;

  const t0 = performance.now();
  function frame(now){
    const t = Math.min(1, (now - t0) / duration);
    const eased = easeInOutCubic(t);
    window.scrollTo(0, startY + delta * eased);
    if (t < 1) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

// 要素を表示→次フレームでターゲットへ確実にスクロール（入力欄ならフォーカス）
function showAndScroll(containerEl, targetEl = null, offset = 120, duration = 600){
  if(!containerEl) return;
  containerEl.classList.remove('hidden');
  // レイアウト確定を2フレーム待つ
  requestAnimationFrame(()=>requestAnimationFrame(()=>{
    const el = targetEl || containerEl;
    // iPadでキーボードを出す前に位置決めしたいので、preventScroll で先にフォーカスだけ
    if (el.tagName === 'INPUT') { try{ el.focus({preventScroll:true}); }catch{} }
    scrollIntoViewSmooth(el, duration, offset);
  }));
}



// ===== 初期化 =====
function init() {

// 合格・不合格の押下エフェクト
wirePressFeedback('#btnPass');
wirePressFeedback('#btnFail');


  try {
    buildOperators();
    buildModes();
    buildParts('#partGrid1'); 
    buildDefects('#defectChips1'); 
    wireToggles('#posChips', '#sideChips', 'pre1');
    buildParts('#partGrid2'); 
    buildDefects('#defectChips2'); 
    wireToggles('#posChips2', '#sideChips2', 'pre2');

    // イベントリスナー（要素の存在チェック付き）
    const mfNoInput = $('#mfNo');
    const prodNameInput = $('#prodName');
    const inqNoInput = $('#inqNo');
    const btnPass = $('#btnPass');
    const btnFail = $('#btnFail');
    const btnSame = $('#btnSame');
    const btnDiff = $('#btnDiff');
    const btnComplex = $('#btnComplex');
    const btnBranchSend = $('#btnBranchSend');
    const btnSendPre1 = $('#btnSendPre1');
    const btnAddLoc = $('#btnAddLoc');
    const btnSendPre2 = $('#btnSendPre2');

// 不合格：modeごとの分岐（スクロール込み）
// 不合格：modeごとの分岐（スムーススクロール）
function handleFail(){
  if (!state.operator) return toast('検査者を選択');
  if (!state.mode)     return toast('検査種別を選択');

  switch (state.mode) {
    case '1': { // 出荷前製品 → 詳細入力カードへ
      const card1 = document.getElementById('preProductFailCard');
      showAndScroll(card1, card1, 80, 600);
      break;
    }
    case '2': { // 出荷前修理 → 分岐カードへ
      const branch = document.getElementById('branchCard');
      showAndScroll(branch, branch, 80, 600);
      break;
    }
    default: { // 3/4 → 即送信
      sendSimpleRecord('fail');
      break;
    }
  }
}


    if(mfNoInput) mfNoInput.addEventListener('input', e => state.pre1.mfNo = e.target.value.trim());
    if(prodNameInput) prodNameInput.addEventListener('input', e => state.pre1.prodName = e.target.value.trim());
    if(inqNoInput) inqNoInput.addEventListener('input', e => state.pre2.inqNo = e.target.value.trim().toUpperCase());

    if(btnPass) btnPass.onclick = handlePass;
    if(btnFail) btnFail.onclick = handleFail;

if(btnSame) btnSame.onclick = () => {
  chooseBranch('same');
  const sameCard = document.getElementById('preRepairSameCard');
  sameCard.classList.remove('hidden');

  // 問い合わせNo.入力欄をターゲットにスクロール
  const inq = document.getElementById('inqNo');
  if (inq) {
    showAndScroll(sameCard, inq, 150, 600); 
  }
};



    if(btnDiff) btnDiff.onclick = () => chooseBranch('diff');
    if(btnComplex) btnComplex.onclick = () => chooseBranch('complex');
    if(btnBranchSend) btnBranchSend.onclick = sendBranch;

    if(btnSendPre1) btnSendPre1.onclick = sendPre1;
    if(btnAddLoc) btnAddLoc.onclick = addLoc;
    if(btnSendPre2) btnSendPre2.onclick = sendPre2;
    
    // 初期状態設定
    updateSendPre2Button();
  } catch(error) {
    console.error('初期化エラー:', error);
  }
}

// 確実な初期化
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}

function refreshActiveUI(){
  // 検査者
  const opKeys = CONFIG.OPERATORS.map(o => o.key);
  $$('#operatorBar .btn').forEach((el, i) => {
    const key = opKeys[i];
    el.classList.toggle('active', state.operator === key);
  });

  // 検査種別
  const modeKeys = CONFIG.MODES.map(m => m.key);
  $$('#modeGrid .btn').forEach((el, i) => {
    const key = modeKeys[i];
    el.classList.toggle('active', state.mode === key);
  });
}

</script>
</body>
</html>